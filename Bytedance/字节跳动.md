## 字节跳动2019届笔试题

### 万万没想到之抓捕孔连顺

#### 题目描述
我叫王大锤，是一名特工。我刚刚接到任务：在字节跳动大街进行埋伏，抓捕恐怖分子孔连顺。和我一起行动的还有另外两名特工，我提议

1. 我们在字节跳动大街的N个建筑中选定3个埋伏地点。
2. 为了相互照应，我们决定相距最远的两名特工间的距离不超过D。

我特喵是个天才! 经过精密的计算，我们从X种可行的埋伏方案中选择了一种。这个方案万无一失，颤抖吧，孔连顺！
……
万万没想到，计划还是失败了，孔连顺化妆成小龙女，混在cosplay的队伍中逃出了字节跳动大街。只怪他的伪装太成功了，就是杨过本人来了也发现不了的！

请听题：给定N（可选作为埋伏点的建筑物数）、D（相距最远的两名特工间的距离的最大值）以及可选建筑的坐标，计算在这次行动中，大锤的小队有多少种埋伏选择。
注意：
1. 两个特工不能埋伏在同一地点
2. 三个特工是等价的：即同样的位置组合(A, B, C) 只算一种埋伏方法，不能因“特工之间互换位置”而重复使用


#### 输入描述:

第一行包含空格分隔的两个数字 N和D(1 ≤ N ≤ 1000000; 1 ≤ D ≤ 1000000)

第二行包含N个建筑物的的位置，每个位置用一个整数（取值区间为[0, 1000000]）表示，从小到大排列（将字节跳动大街看做一条数轴）


#### 输出描述

一个数字，表示不同埋伏方案的数量。结果可能溢出，请对 99997867 取模

#### 示例输入1

	4 3
	
	1 2 3 4

#### 示例输出1

	4
#### 说明
可选方案 (1, 2, 3), (1, 2, 4), (1, 3, 4), (2, 3, 4)

#### 示例输入2

	5 19
	
	1 10 20 30 50

#### 示例输出2

	1

#### 说明

可选方案 (1, 10, 20)

#### 解题思路

边输入数边确定之前的数字的满足条件的起始范围，在此范围内的除刚刚输入的数之外的数字有num个，随机取两个数组成三角的方法数为(num-1)*num/2。

#### [完整代码](https://github.com/traviszeng/techInterviewCode/blob/master/Bytedance/bytedance1.cpp)

### 毕业旅行

#### 题目描述

小明目前在做一份毕业旅行的规划。打算从北京出发，分别去若干个城市，然后再回到北京，每个城市之间均乘坐高铁，且每个城市只去一次。
由于经费有限，希望能够通过合理的路线安排尽可能的省一些路上的花销。给定一组城市和每对城市之间的火车票的价钱，找到每个城市只访问一次并返回起点的最小车费花销。

#### 输入描述:

城市个数n（1<n≤20，包括北京）

城市间的车票价钱 n行n列的矩阵 m[n][n]

#### 输出描述:

最小车费花销 s

#### 示例输入1

	4
	0 2 6 5
	2 0 4 4
	6 4 0 2
	5 4 2 0

#### 示例输出1

	13

#### 说明
共 4 个城市，城市 1 和城市 1 的车费为0，城市 1 和城市 2 之间的车费为 2，
城市 1 和城市 3 之间的车费为 6，城市 1 和城市 4 之间的车费为 5，依次类推。
假设任意两个城市之间均有单程票可购买，且票价在1000元以内，无需考虑极端情况。

#### 解题思路

将城市进行二进制编码 例如若有4个城市 则1010表示选取第二个和第四个城市，dp[i][j]表示经过了i集合中的所有城市且以j结尾的路径最小值。

状态转移方程为dp[i][j] = min(dp[i][k]+cities[k][j],dp[i][j])   其中k是i集合中的一个城市

#### [完整代码](https://github.com/traviszeng/techInterviewCode/blob/master/Bytedance/bytedance2.cpp)

### 雀魂启动

#### 题目描述

小包最近迷上了一款叫做雀魂的麻将游戏，但是这个游戏规则太复杂，小包玩了几个月了还是输多赢少。
于是生气的小包根据游戏简化了一下规则发明了一种新的麻将，只留下一种花色，并且去除了一些特殊和牌方式（例如七对子等），具体的规则如下：

总共有36张牌，每张牌是1~9。每个数字4张牌。
你手里有其中的14张牌，如果这14张牌满足如下条件，即算作和牌
14张牌中有2张相同数字的牌，称为雀头。
除去上述2张牌，剩下12张牌可以组成4个顺子或刻子。顺子的意思是递增的连续3个数字牌（例如234,567等），刻子的意思是相同数字的3个数字牌（例如111,777）

例如：

1 1 1 2 2 2 6 6 6 7 7 7 9 9 可以组成1,2,6,7的4个刻子和9的雀头，可以和牌

1 1 1 1 2 2 3 3 5 6 7 7 8 9 用1做雀头，组123,123,567,789的四个顺子，可以和牌

1 1 1 2 2 2 3 3 3 5 6 7 7 9 无论用1 2 3 7哪个做雀头，都无法组成和牌的条件。

现在，小包从36张牌中抽取了13张牌，他想知道在剩下的23张牌中，再取一张牌，取到哪几种数字牌可以和牌。

#### 输入描述:

输入只有一行，包含13个数字，用空格分隔，每个数字在1~9之间，数据保证同种数字最多出现4次。


#### 输出描述:

输出同样是一行，包含1个或以上的数字。代表他再取到哪些牌可以和牌。若满足条件的有多种牌，请按从小到大的顺序输出。若没有满足条件的牌，请输出一个数字0

#### 示例输入1

	1 1 1 2 2 2 5 5 5 6 6 6 9

#### 输出

	9
#### 说明

可以组成1,2,6,7的4个刻子和9的雀头

#### 示例输入2

	1 1 1 1 2 2 3 3 5 6 7 8 9

#### 输出
	4 7

#### 说明

用1做雀头，组123,123,567或456,789的四个顺子

#### 示例输入3

	1 1 1 2 2 2 3 3 3 5 7 7 9

#### 输出

	0

#### 说明

来任何牌都无法和牌

#### 解题思路

将1-9的牌的数量存在数组中，循环添加1-9的牌看添加后是否可以满足胡牌条件。

胡牌检验过程为递归，用flag指示当前递归的过程。先去掉组成对子的牌，再检验是否可以组成刻子和顺子。若最后所有牌都被划掉则说明可以胡牌。

#### [完整代码](https://github.com/traviszeng/techInterviewCode/blob/master/Bytedance/bytedance3.cpp)
